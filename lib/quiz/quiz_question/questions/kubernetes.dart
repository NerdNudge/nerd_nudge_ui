import 'dart:convert';

class KubernetesQuestions {
  int index = 0;

  List questions = [
    json.decode('{"title":"Primary Use of Kubernetes","question":"What is Kubernetes primarily used for?","possible_answers":{"A":"Automating digital marketing","B":"Cloud storage management","C":"Container orchestration","D":"Big data analytics"},"answer_percentages":{"A":5.0,"B":5.0,"C":85.0,"D":5.0},"right_answer":"C","topic_name":"Kubernetes Basics","description_and_explanation":"Kubernetes is an open-source platform designed to automate deploying, scaling, and operating application containers. It helps manage clustered groups of containers, including Docker containers, with all the tools needed to run containerized applications.","difficulty_level":"Easy","pro_tip":"Leverage Kubernetes for managing microservices architectures and containerized applications for better resource utilization and scalability.","fun_fact":"Kubernetes, also known as K8s, was originally designed by Google and is now maintained by the Cloud Native Computing Foundation."}'),
    json.decode('{"title":"Kubernetes Deployments","question":"Which Kubernetes object is used to manage a set of replica pods?","possible_answers":{"A":"Deployment","B":"Service","C":"Volume","D":"Namespace"},"answer_percentages":{"A":80.0,"B":10.0,"C":5.0,"D":5.0},"right_answer":"A","topic_name":"Kubernetes Objects","description_and_explanation":"A Deployment in Kubernetes provides declarative updates to Pods and ReplicaSets. It allows you to describe an application\'s life cycle, such as which images to use for the app, the number of pods, and the way to update them, among other aspects of application management.","difficulty_level":"Medium","pro_tip":"Use Deployments to create and scale applications dynamically and manage the update process seamlessly.","fun_fact":"Deployments are one of the most commonly used Kubernetes objects because they manage the whole lifecycle of applications on the platform."}'),
    json.decode('{"title":"Container Scheduling in Kubernetes","question":"What component in Kubernetes is responsible for automatically placing containers based on their resource requirements?","possible_answers":{"A":"Kube-proxy","B":"Kube-scheduler","C":"Kubelet","D":"Etcd"},"answer_percentages":{"A":5.0,"B":85.0,"C":5.0,"D":5.0},"right_answer":"B","topic_name":"Kubernetes Components","description_and_explanation":"The kube-scheduler is a component of Kubernetes that automatically places containers based on their resource requirements and other constraints, while not sacrificing availability. It selects the most suitable node for the container to run based on the current state of the cluster.","difficulty_level":"Medium","pro_tip":"Ensure that your cluster nodes have enough resources to meet the demands of your applications to optimize the scheduling process.","fun_fact":"The scheduler uses a complex algorithm that factors in compute resource requirements, hardware/software constraints, and other user-provided specifications."}'),
    json.decode('{"title":"Namespace Management in Kubernetes","question":"Which Kubernetes feature allows you to group pods and provide network policies and access control for them?","possible_answers":{"A":"Namespaces","B":"Services","C":"Ingress","D":"Volumes"},"answer_percentages":{"A":80.0,"B":5.0,"C":10.0,"D":5.0},"right_answer":"A","topic_name":"Kubernetes Namespaces","description_and_explanation":"Namespaces in Kubernetes allow you to partition resources into logically named groups, which provides a scope for naming resources and can simplify complex system architecture and enhance security, including network policies, access controls, and quotas.","difficulty_level":"Easy","pro_tip":"Use namespaces to maintain environmental separation within the same cluster, such as development, testing, and production.","fun_fact":"Namespaces help manage clusters with many users spread across multiple teams or projects."}'),
    json.decode('{"title":"Services in Kubernetes","question":"What is the main purpose of a Kubernetes Service?","possible_answers":{"A":"To expose a set of pods as a network service","B":"To manage the underlying cloud infrastructure","C":"To monitor the health of the cluster","D":"To automate the deployment process"},"answer_percentages":{"A":90.0,"B":3.0,"C":2.0,"D":5.0},"right_answer":"A","topic_name":"Kubernetes Services","description_and_explanation":"A Kubernetes Service is an abstraction that defines a logical set of Pods and a policy by which to access them. This can include settings for load-balancing, service discovery, and static IP addresses, making it easy to expose application running on a set of Pods as a network service.","difficulty_level":"Medium","pro_tip":"Utilize Services to create reliable and accessible applications within your Kubernetes environment.","fun_fact":"Services in Kubernetes maintain connectivity to the Pods even when the pods are rescheduled on different nodes due to failures."}'),
    json.decode('{"title":"Pod-Native Containers in Kubernetes","question":"What does it mean for a container to be \'pod-native\' in Kubernetes?","possible_answers":{"A":"It is optimized for running on bare-metal","B":"It directly communicates with the Kubernetes API","C":"It is designed to run tightly coupled in the same pod","D":"It uses standard Docker runtime environments"},"answer_percentages":{"A":5.0,"B":10.0,"C":80.0,"D":5.0},"right_answer":"C","topic_name":"Pod Design","description_and_explanation":"Being \'pod-native\' means that the container is designed to run in tight coupling within the same pod. This design is optimal for containers that need to share resources like storage and network but maintain a high level of inter-process communication and dependency.","difficulty_level":"Hard","pro_tip":"Design your applications to be pod-native to fully exploit Kubernetes\' capabilities for managing closely related containers.","fun_fact":"The concept of pod-native applications highlights the unique approach Kubernetes takes towards container orchestration, as opposed to other platforms."}'),
    json.decode('{"title":"Handling Failures in Kubernetes","question":"How does Kubernetes handle container failures?","possible_answers":{"A":"By restarting the failed containers automatically","B":"By sending notifications to the administrator","C":"By deleting failed containers","D":"By ignoring the failure"},"answer_percentages":{"A":95.0,"B":1.0,"C":1.0,"D":3.0},"right_answer":"A","topic_name":"Failure Management","description_and_explanation":"Kubernetes handles container failures by automatically restarting the failed containers, depending on the restart policy that has been set. This allows for high availability and fault tolerance within the applications running on the cluster.","difficulty_level":"Easy","pro_tip":"Configure the restart policy of your pods according to the criticality and requirements of your application to ensure uninterrupted service.","fun_fact":"The default restart policy in Kubernetes is \'Always\', which means that the container will be restarted even if it exits successfully."}'),
    json.decode('{"title":"ConfigMaps in Kubernetes","question":"What is a ConfigMap in Kubernetes?","possible_answers":{"A":"A way to store configuration files for containers","B":"A component that manages secure communications","C":"A storage unit for database management","D":"A tool to update container images"},"answer_percentages":{"A":90.0,"B":2.0,"C":3.0,"D":5.0},"right_answer":"A","topic_name":"Configuration Management","description_and_explanation":"A ConfigMap is a Kubernetes resource used to store non-confidential data in key-value pairs. Pods can consume ConfigMaps as environment variables, command-line arguments, or as configuration files in a volume. This allows you to keep containerized applications portable and easy to configure.","difficulty_level":"Medium","pro_tip":"Use ConfigMaps to separate configuration artifacts from image content to keep containerized applications portable and easy to configure.","fun_fact":"ConfigMaps allow developers to store configuration settings independently of container image data, reducing the need for image updates when configuration changes are required."}'),
    json.decode('{"title":"Autoscaling with Kubernetes","question":"Which Kubernetes resource is used to automatically scale pods based on observed CPU utilization?","possible_answers":{"A":"Horizontal Pod Autoscaler","B":"Vertical Pod Autoscaler","C":"Cluster Autoscaler","D":"Manual Scaler"},"answer_percentages":{"A":95.0,"B":2.0,"C":2.0,"D":1.0},"right_answer":"A","topic_name":"Autoscaling","description_and_explanation":"The Horizontal Pod Autoscaler automatically scales the number of pods in a replication controller, deployment, replica set, or stateful set based on observed CPU utilization or other select metrics. This feature allows Kubernetes to handle the load dynamically and maintain performance during spikes in demand.","difficulty_level":"Medium","pro_tip":"Implement Horizontal Pod Autoscaler to maintain application performance and cost efficiency under varying loads.","fun_fact":"The Horizontal Pod Autoscaler was one of the first automation features implemented in Kubernetes to support auto-scaling functionality."}'),
    json.decode('{"title":"Etcd Role in Kubernetes","question":"What role does \'etcd\' play in a Kubernetes cluster?","possible_answers":{"A":"It stores the state of the cluster","B":"It schedules the pods","C":"It balances the load among nodes","D":"It monitors the health of the cluster"},"answer_percentages":{"A":90.0,"B":5.0,"C":2.0,"D":3.0},"right_answer":"A","topic_name":"Kubernetes Architecture","description_and_explanation":"Etcd is a key-value store used as Kubernetes\' backing store for all cluster data. It maintains the state of a Kubernetes cluster, including nodes, pods, configs, and secrets, ensuring that state is distributed consistently across the cluster and is always available to Kubernetes master components.","difficulty_level":"Hard","pro_tip":"Regularly back up your etcd data to ensure cluster stability and to prevent data loss in the event of a failure.","fun_fact":"Etcd is written in Go and is based on the Raft consensus algorithm to manage a highly-available replicated log."}'),
    json.decode('{"title":"Kubernetes Ingress","question":"What is the Kubernetes Ingress?","possible_answers":{"A":"A command-line tool to interact with Kubernetes","B":"A type of service that provides dynamic IP addressing","C":"An API object that manages external access to the services in a cluster","D":"A security feature that restricts ingress traffic"},"answer_percentages":{"A":5.0,"B":5.0,"C":85.0,"D":5.0},"right_answer":"C","topic_name":"Network Management","description_and_explanation":"Ingress is a Kubernetes API object that manages external access to the services in a cluster, typically HTTP. Ingress may provide load balancing, SSL termination, and name-based virtual hosting. It is an efficient way to expose your services externally without creating dozens of external load balancers or exposing each service on the node.","difficulty_level":"Medium","pro_tip":"Use Ingress to efficiently manage access to services in your Kubernetes cluster, especially when operating multiple services that require internet access.","fun_fact":"Ingress controllers are pivotal in managing the traffic routing rules and are often implemented by third-party tools like Nginx or HAProxy."}')
  ];

  KubernetesQuestions._privateConstructor();
  static final KubernetesQuestions _instance = KubernetesQuestions._privateConstructor();

  factory KubernetesQuestions() {
    return _instance;
  }

  getNextQuestion() {
    index = (index == questions.length - 1) ? 0 : index + 1;
    return questions[index];
  }

  getNextQuestionsList(int count) {
    index = (index == questions.length - 1) ? 0 : index + 1;
    var questionsList = [];
    for(int i = index; i < count; i ++) {
      questionsList.add(questions[index]);
      index = (index == questions.length - 1) ? 0 : index + 1;
    }
    return questionsList;
  }
}